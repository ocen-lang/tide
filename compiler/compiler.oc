import std::vector::{ Vector }
import std::span::{ Span }
import std::sv::{ SV }

import @ast::nodes::{ AST, Variable, Symbol }
import @errors::{ Error }
import @bytecode::{ Chunk, OpCode  }
import @vm::{ VM, allocate_object }
import @vm::value::{ Value, String, Function }

struct LocalVar {
    sym: &Symbol
    depth: i32
}

struct Compiler {
    vm: &VM
    chunk: &Chunk
    locals: &Vector<LocalVar>
    scope_depth: u32
}

def Compiler::make(vm: &VM, span: Span): Compiler {
    let chunk = Chunk::new(span)
    let locals = Vector<LocalVar>::new(capacity: 256)
    return Compiler(
        vm,
        chunk,
        locals,
        scope_depth: 0,
    )
}

def Compiler::make_str(&this, text: SV): Value {
    return .vm.copy_string(text.data, text.len)
}

def Compiler::begin_scope(&this) => .scope_depth++
def Compiler::end_scope(&this, span: Span) {
    .scope_depth--
    while .locals.size > 0 and .locals.back().depth as u32 > .scope_depth {
        .chunk.push(Pop, Span(span.end, span.end))
        .locals.pop()
    }
}

def Compiler::find_local(&this, name: SV, span: Span): i32 {
    for let i = 0; i < .locals.size; i++ {
        let idx = .locals.size - i - 1
        let local = .locals[idx]
        if local.sym.name == name {
            if idx < 0 {
                Error::new(
                    span, "Compiler: Variable used before initialization."
                ).panic()
            }
            return idx as i32
        }
    }
    return -1
}

//! Create a new variable in the current scope
def Compiler::create_variable(&this, sym: &Symbol) {
    // Global variable
    if .scope_depth == 0 {
        return 
    }

    // Local variable
    let local_var = LocalVar(sym, -1) // Uninitialized...
    .locals.push(local_var)
}

//! Mark the last defined variable as initialized
def Compiler::mark_variable_initialized(&this) {
    if .scope_depth == 0 {
        return
    }

    let idx = .locals.size - 1
    .locals.data[idx].depth = .scope_depth as i32
} 

//! Save the value on the top of the stack to last defined variable
def Compiler::define_variable(&this, sym: &Symbol) {
    // Local variable, nothing to do
    if .scope_depth > 0 {
        return
    }
    // Global variable
    .chunk.push_with_value(SetGlobal, .make_str(sym.name), sym.span)
    .chunk.push(Pop, sym.span)
}

def Compiler::find_variable(&this, name: SV, span: Span) {
    let local_idx = .find_local(name, span)
    // Global Variable
    if local_idx < 0 {
        .chunk.push_with_value(GetGlobal, .make_str(name), span)
    
    // Local Variable
    } else {
        .chunk.push_with_arg(GetLocal, local_idx as u16, span)
    }
}

def Compiler::compile_expression(&this, node: &AST) {
    match node.type {
        IntLiteral => {
            let value = Value::Int(node.u.num_literal.text.to_i32())
            .chunk.push_with_value(Constant, value, node.span)
        }
        FloatLiteral => {
            let value = Value::Float(std::libc::strtod(node.u.num_literal.text, null))
            .chunk.push_with_value(Constant, value, node.span)
        }
        StringLiteral => {
            let text = node.u.string_literal
            .chunk.push_with_value(Constant, .make_str(text), node.span)
        }
        BoolLiteral => {
            let value = Value::Bool(node.u.bool_literal)
            .chunk.push_with_value(Constant, value, node.span)
        }
        Identifier => .find_variable(node.u.ident.name, node.span)
        Call => {
            let callee = node.u.call.callee

            // FIXME: Hack for printing...
            if callee.is_identifier() and callee.u.ident.name == "print" {
                let args = node.u.call.args
                for arg in args.iter() {
                    .compile_expression(arg.expr)
                }
                .chunk.push_with_arg(Print, args.size as u16, node.span)
                return
            }

            let args = node.u.call.args
            if args.size > 0 {
                Error::new(
                    node.span, "Compiler: Function calls with arguments are not yet supported."
                ).panic()
            }

            .compile_expression(callee)
            .chunk.push(Call, node.span)
        }
        BinaryOp => match node.u.binary.op {
            Assignment => {
                .compile_expression(node.u.binary.rhs)

                let lhs = node.u.binary.lhs
                match lhs.type {
                    Identifier => {
                        let name = lhs.u.ident.name
                        let idx = .find_local(lhs.u.ident.name, lhs.span)
                        
                        // Global variable
                        if idx < 0 {
                            .chunk.push_with_value(SetGlobal, .make_str(name), node.span)

                        // Local variable
                        } else {
                            .chunk.push_with_arg(SetLocal, idx as u16, node.span)
                        }
                    }
                    else => {
                        Error::new(
                            lhs.span, f"Cannot assign to {lhs.type}"
                        ).panic()
                    }
                }
            }
            And => {
                .compile_expression(node.u.binary.lhs)
                let false_jump = .make_jump(JumpIfFalse, node.span)
                .chunk.push(Pop, node.span)
                .compile_expression(node.u.binary.rhs)
                .patch_jump(false_jump, node.span)
            }
            Or => {
                .compile_expression(node.u.binary.lhs)
                let false_jump = .make_jump(JumpIfFalse, node.span)
                let true_jump = .make_jump(Jump, node.span)
                .patch_jump(false_jump, node.span)
                .chunk.push(Pop, node.span)
                .compile_expression(node.u.binary.rhs)
                .patch_jump(true_jump, node.span)
            }
            // Generic Binary operators
            else => {
                .compile_expression(node.u.binary.lhs)
                .compile_expression(node.u.binary.rhs)
                match node.u.binary.op {
                    Plus => .chunk.push(Add, node.u.binary.op_span),
                    Minus => .chunk.push(Sub, node.u.binary.op_span),
                    Multiply => .chunk.push(Mul, node.u.binary.op_span),
                    Divide => .chunk.push(Div, node.u.binary.op_span),
                    LessThan => .chunk.push(LessThan, node.u.binary.op_span),
                    GreaterThan => .chunk.push(GreaterThan, node.u.binary.op_span),
                    Equals => .chunk.push(Equal, node.u.binary.op_span),
                    else => std::panic(`Unimplemented binary operator: {node.u.binary.op}`)
                }
            }
        }
        else => {
            Error::new(
                node.span, f"Unimplemented `{node.type}` in Compiler::compile_expression"
            ).panic()
        }
    }
}

def Compiler::make_jump(&this, op: OpCode, span: Span): u32 {
    .chunk.push_with_arg(op, 0xbeef, span) // Placeholder
    let patch_off = .chunk.code.size - 2
    return patch_off
}

def Compiler::make_loop(&this, target: u32, span: Span) {
    let offset = .chunk.code.size - target + 3
    if offset > 0xffff {
        Error::new(
            span, "Compiler: Loop offset too large."
        ).panic()
    }

    .chunk.push_with_arg(Loop, offset as u16, span)
}

def Compiler::patch_jump(&this, from: u32, span: Span) {
    let offset = .chunk.code.size - from - 2
    if offset > 0xffff {
        Error::new(
            span, "Compiler: Jump offset too large."
        ).panic()
    }

    .chunk.code.data[from + 0] = (offset >> 8) as u8 & 0xff
    .chunk.code.data[from + 1] = offset as u8
}

def Compiler::compile_if(&this, node: &AST, is_expression: bool = false) {
    let ifs = &node.u.if_stmt
    .compile_expression(ifs.cond)

    let false_jump = .make_jump(JumpIfFalse, ifs.cond.span)
    .chunk.push(Pop, ifs.cond.span)
    .compile_statement(ifs.body)
    let end_jump = .make_jump(Jump, ifs.body.span)

    .patch_jump(false_jump, ifs.cond.span)
    .chunk.push(Pop, ifs.cond.span)
    if ifs.els? {
        .compile_statement(ifs.els)
    }
    .patch_jump(end_jump, ifs.body.span)
}

def Compiler::compile_statement(&this, node: &AST) {
    match node.type {
        Block => {
            .begin_scope()

            for s in node.u.block.statements.iter() {
                .compile_statement(s)
            }

            .end_scope(node.span)
        }
        VarDeclaration => {
            let sym = node.u.var_decl.var.sym
            let expr = node.u.var_decl.init
            if expr? {
                .compile_expression(expr)
            } else {
                .chunk.push(Null, node.span)
            }
            .create_variable(sym)
            .define_variable(sym)
            .mark_variable_initialized()
        }
        Function => {
            let ast_func = node.u.func

            .create_variable(ast_func.sym)
            .mark_variable_initialized()

            let name_val = .make_str(ast_func.sym.name)
            let func_obj = allocate_object<Function>(.vm, Function)
            func_obj.name = name_val.as_string()

            let chunk_compiler = Compiler::make(.vm, node.span)
            chunk_compiler.compile_statement(ast_func.body)

            // Add a placeholder return statement if none was provided
            chunk_compiler.chunk.push_with_value(Constant, Value::Null(), node.span)
            chunk_compiler.chunk.push(Return, node.span)

            func_obj.chunk = chunk_compiler.chunk

            let func_val = Value::Object(&func_obj.obj)
            .chunk.push_with_value(Constant, func_val, node.span)

            .define_variable(ast_func.sym)
        }
        If => .compile_if(node, is_expression: false)
        While => {
            let loop = &node.u.loop
            let start = .chunk.code.size
            .compile_expression(loop.cond)
            let false_jump = .make_jump(JumpIfFalse, loop.cond.span)
            .chunk.push(Pop, loop.cond.span)

            .compile_statement(loop.body)

            .make_loop(start, loop.cond.span)
            .patch_jump(false_jump, loop.cond.span)
            .chunk.push(Pop, loop.cond.span)
        }
        For => {
            let loop = &node.u.loop
            .begin_scope()

            if loop.init? {
                .compile_statement(loop.init)
            }

            let start = .chunk.code.size
            if loop.cond? {
                .compile_expression(loop.cond)
            } else {
                .chunk.push_with_value(Constant, Value::True(), node.span)
            }

            let false_jump = .make_jump(JumpIfFalse, node.span)
            .chunk.push(Pop, node.span)

            .compile_statement(loop.body)

            if loop.step? {
                .compile_statement(loop.step)
            }

            .make_loop(start, node.span)
            .patch_jump(false_jump, node.span)
            .chunk.push(Pop, node.span)

            .end_scope(node.span)
        }
        Return => {
            if node.u.child? {
                .compile_expression(node.u.child)
            } else {
                .chunk.push(Null, node.span)
            }
            .chunk.push(Return, node.span)
        }
        else => {
            .compile_expression(node)
            .chunk.push(Pop, node.span)
        }
    }
}

def Compiler::compile_ns(&this, root: &AST) {
    assert root.type == Namespace, "Root node must be a namespace."
    for stmt in root.u.ns.statements.iter() {
        .compile_statement(stmt)
    }
}

// TODO: More complex structures than just expressions?
def compile_program(vm: &VM, root: &AST): &Chunk {
    let compiler = Compiler::make(vm, root.span)
    compiler.compile_ns(root)
    compiler.chunk.push(Halt, root.span)
    return compiler.chunk
}
