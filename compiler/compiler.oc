import std::vector::{ Vector }
import std::span::{ Span }
import std::sv::{ SV }

import @ast::nodes::{ AST, Variable, Symbol }
import @errors::{ Error }
import @bytecode::chunk::{ Chunk,  }
import @bytecode::instruction::{ Instruction, OpCode  }
import @vm::{ VM, allocate_object }
import @vm::value::{ Value, String, Function }

struct LocalVar {
    sym: &Symbol
    depth: i32
}

struct Compiler {
    vm: &VM
    chunk: &Chunk
    locals: &Vector<LocalVar>
    scope_depth: u32
}

def Compiler::make(vm: &VM, span: Span): Compiler {
    let chunk = Chunk::new(span)
    let locals = Vector<LocalVar>::new(capacity: 256)
    return Compiler(
        vm,
        chunk,
        locals,
        scope_depth: 0,
    )
}

def Compiler::make_str(&this, text: SV): Value {
    return .vm.copy_string(text.data, text.len)
}

def Compiler::begin_scope(&this) => .scope_depth++
def Compiler::end_scope(&this) => .scope_depth--

def Compiler::find_local(&this, name: SV): i32 {
    for let i = 0; i < .locals.size; i++ {
        let idx = .locals.size - i - 1
        let local = .locals[idx]
        if local.sym.name == name {
            return idx as i32
        }
    }
    return -1
}

def Compiler::declare_variable(&this, sym: &Symbol) {
    // Global variable
    if .scope_depth == 0 {
        .chunk.push_literal(SetGlobal, .make_str(sym.name), sym.span)

    // Local variable
    } else {
        // FIXME: Check if we're re-defining a variable in scope
        let local_var = LocalVar(sym, .scope_depth as i32)
        .locals.push(local_var)
    }
}

def Compiler::find_variable(&this, name: SV, span: Span) {
    let local_idx = .find_local(name)
    // Global Variable
    if local_idx < 0 {
        .chunk.push_literal(GetGlobal, .make_str(name), span)
    
    // Local Variable
    } else {
        let inst = Instruction::make_literal(GetLocal, local_idx as u16)
        .chunk.push(inst, span)
    }
}

def Compiler::compile_expression(&this, node: &AST) {
    match node.type {
        IntLiteral => {
            let value = Value::Int(node.u.num_literal.text.to_i32())
            .chunk.push_literal(Constant, value, node.span)
        }
        FloatLiteral => {
            let value = Value::Float(std::libc::strtod(node.u.num_literal.text, null))
            .chunk.push_literal(Constant, value, node.span)
        }
        StringLiteral => {
            let text = node.u.string_literal
            .chunk.push_literal(Constant, .make_str(text), node.span)
        }
        Identifier => .find_variable(node.u.ident.name, node.span)
        Call => {
            let callee = node.u.call.callee

            // FIXME: Hack for printing...
            if callee.is_identifier() and callee.u.ident.name == "print" {
                let args = node.u.call.args
                for arg in args.iter() {
                    .compile_expression(arg.expr)
                }
                let inst = Instruction::make_literal(Print, args.size as u16)
                .chunk.push(inst, node.span)
                return
            }

            let args = node.u.call.args
            if args.size > 0 {
                Error::new(
                    node.span, "Compiler: Function calls with arguments are not yet supported."
                ).panic()
            }

            .compile_expression(callee)
            .chunk.push(Instruction::make(Call), node.span)
        }
        BinaryOp => match node.u.binary.op {
            Assignment => {
                .compile_expression(node.u.binary.rhs)

                let lhs = node.u.binary.lhs
                match lhs.type {
                    Identifier => {
                        let name = lhs.u.ident.name
                        let idx = .find_local(lhs.u.ident.name)
                        
                        // Global variable
                        if idx < 0 {
                            .chunk.push_literal(SetGlobal, .make_str(name), node.span)

                        // Local variable
                        } else {
                            let inst = Instruction::make_literal(SetLocal, idx as u16)
                            .chunk.push(inst, node.span)
                        }
                    }
                    else => {
                        Error::new(
                            lhs.span, f"Cannot assign to {lhs.type}"
                        ).panic()
                    }
                }
            }
            // Generic Binary operators
            else => {
                .compile_expression(node.u.binary.lhs)
                .compile_expression(node.u.binary.rhs)
                match node.u.binary.op {
                    Plus => .chunk.push(Instruction::make(Add), node.u.binary.op_span),
                    Minus => .chunk.push(Instruction::make(Sub), node.u.binary.op_span),
                    Multiply => .chunk.push(Instruction::make(Mul), node.u.binary.op_span),
                    Divide => .chunk.push(Instruction::make(Div), node.u.binary.op_span),
                    else => std::panic(`Unimplemented binary operator: {node.u.binary.op}`)
                }
            }
        }
        else => {
            Error::new(
                node.span, f"Unimplemented `{node.type}` in Compiler::compile_expression"
            ).panic()
        }
    }
}

def Compiler::compile_statement(&this, node: &AST) {
    match node.type {
        Block => {
            .begin_scope()

            for s in node.u.block.statements.iter() {
                .compile_statement(s)
            }

            .end_scope()

            while .locals.size > 0 and .locals.back().depth as u32 > .scope_depth {
                .chunk.push(Instruction::make(Pop), Span(node.span.end, node.span.end))
                .locals.pop()
            }
        }
        VarDeclaration => {
            let name = node.u.var_decl.var.sym.name
            let expr = node.u.var_decl.init
            if expr? {
                .compile_expression(expr)
            } else {
                .chunk.push(Instruction::make(Null), node.span)
            }
            .declare_variable(node.u.var_decl.var.sym)
        }
        Function => {
            let ast_func = node.u.func

            let name_val = .make_str(ast_func.sym.name)
            let func_obj = allocate_object<Function>(.vm, Function)
            func_obj.name = name_val.as_string()

            let chunk_compiler = Compiler::make(.vm, node.span)
            chunk_compiler.compile_statement(ast_func.body)

            // Add a placeholder return statement if none was provided
            chunk_compiler.chunk.push_literal(Constant, Value::Null(), node.span)
            chunk_compiler.chunk.push(Instruction::make(Return), node.span)

            func_obj.chunk = chunk_compiler.chunk

            let func_val = Value::Object(&func_obj.obj)
            .chunk.push_literal(Constant, func_val, node.span)

            .declare_variable(ast_func.sym)
        }
        else => {
            .compile_expression(node)
            .chunk.push(Instruction::make(Pop), node.span)
        }
    }
}

def Compiler::compile_ns(&this, root: &AST) {
    assert root.type == Namespace, "Root node must be a namespace."
    for stmt in root.u.ns.statements.iter() {
        .compile_statement(stmt)
    }
}

// TODO: More complex structures than just expressions?
def compile_program(vm: &VM, root: &AST): &Chunk {
    let compiler = Compiler::make(vm, root.span)
    compiler.compile_ns(root)
    return compiler.chunk
}
