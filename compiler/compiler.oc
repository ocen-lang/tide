import std::vector::{ Vector }
import std::span::{ Span }
import std::sv::{ SV }

import @ast::nodes::{ AST, Variable, Symbol }
import @errors::{ Error }
import @bytecode::{ Chunk, OpCode  }
import @vm::{ VM, allocate_object }
import @vm::value::{ Value, String, FunctionCode }

struct LocalVar {
    sym: &Symbol
    depth: i32
    captured: bool
}

struct UpVar {
    idx: u16
    is_local: bool
}

struct Compiler {
    vm: &VM
    func: &FunctionCode
    chunk: &Chunk
    upvars: &Vector<UpVar>
    locals: &Vector<LocalVar>
    scope_depth: u32
    enclosing: &Compiler
}

def Compiler::make(func: &FunctionCode, vm: &VM, span: Span, enclosing: &Compiler = null): Compiler {
    let chunk = Chunk::new(span)
    let locals = Vector<LocalVar>::new()
    let upvars = Vector<UpVar>::new(capacity: 256)
    return Compiler(
        vm,
        func,
        func.chunk,
        upvars,
        locals,
        scope_depth: 0,
        enclosing
    )
}

def Compiler::free(&this) {
    .locals.free()
    .upvars.free()
}

def Compiler::make_str(&this, text: SV): Value {
    return .vm.copy_string(text.data, text.len)
}

def Compiler::begin_scope(&this) => .scope_depth++
def Compiler::end_scope(&this, span: Span) {
    .scope_depth--
    while .locals.size > 0 and .locals.back().depth as u32 > .scope_depth {
        let var = .locals.pop()
        if var.captured {
            .chunk.push_op(CloseUpvalue, span)
        } else {
            .chunk.push_op(Pop, span)
        }
    }
}

def Compiler::find_local(&this, name: SV, span: Span): i32 {
    for let i = 0; i < .locals.size; i++ {
        let idx = .locals.size - i - 1
        let local = .locals[idx]
        if local.sym.name == name {
            if idx < 0 {
                Error::new(
                    span, "Compiler: Variable used before initialization."
                ).panic()
            }
            return idx as i32
        }
    }
    return -1
}

def Compiler::add_upvar(&this, idx: u16, is_local: bool, span: Span): i32 {
    for let i = 0; i < .upvars.size; i++ {
        let up = .upvars[i]
        if (up.idx == idx and up.is_local == is_local) {
            return i as i32
        }
    }

    let res = .upvars.size

    if res > 0xffff {
        Error::new(
            span, "Compiler: Too many upvalues in function."
        ).panic()
    }

    .upvars.push(UpVar(idx, is_local))
    return res as i32
}

def Compiler::find_upvar(&this, name: SV, span: Span): i32 {
    if not .enclosing? return -1

    let local_idx = .enclosing.find_local(name, span)
    if local_idx >= 0 {
        let var = .enclosing.locals.at_ptr(local_idx as u32)
        var.captured = true
        return .add_upvar(local_idx as u16, true, span)
    }

    let up_idx = .enclosing.find_upvar(name, span)
    if up_idx >= 0 {
        return .add_upvar(up_idx as u16, false, span)
    }

    return -1
}

//! Create a new variable in the current scope
def Compiler::create_variable(&this, sym: &Symbol) {
    // Global variable
    if .scope_depth == 0 {
        return 
    }

    // Local variable
    let local_var = LocalVar(sym, -1, false) // Uninitialized...
    .locals.push(local_var)
}

//! Mark the last defined variable as initialized
def Compiler::mark_variable_initialized(&this) {
    if .scope_depth == 0 {
        return
    }

    let idx = .locals.size - 1
    .locals.data[idx].depth = .scope_depth as i32
} 

//! Save the value on the top of the stack to last defined variable
def Compiler::define_variable(&this, sym: &Symbol) {
    // Local variable, nothing to do
    if .scope_depth > 0 {
        return
    }

    // Global variable
    .chunk.push_with_literal(SetGlobal, .make_str(sym.name), sym.span)
    .chunk.push_op(Pop, sym.span)
}

def Compiler::compile_variable(&this, name: SV, span: Span) {
    let local_idx = .find_local(name, span)
    if local_idx >= 0 {
        // Local Variable
        .chunk.push_with_arg_u16(GetLocal, local_idx as u16, span)
        return
    }

    let up_idx = .find_upvar(name, span)
    if up_idx >= 0 {
        // Upvalue
        .chunk.push_with_arg_u16(GetUpvalue, up_idx as u16, span)
        return
    }

    // Global Variable
    .chunk.push_with_literal(GetGlobal, .make_str(name), span)
}

def Compiler::make_jump(&this, op: OpCode, span: Span): u32 {
    .chunk.push_with_arg_u16(op, 0xbeef, span) // Placeholder
    let patch_off = .chunk.code.size - 2
    return patch_off
}

def Compiler::make_loop(&this, target: u32, span: Span) {
    let offset = .chunk.code.size - target + 3
    if offset > 0xffff {
        Error::new(
            span, "Compiler: Loop offset too large."
        ).panic()
    }

    .chunk.push_with_arg_u16(Loop, offset as u16, span)
}

def Compiler::patch_jump(&this, from: u32, span: Span) {
    let offset = .chunk.code.size - from - 2
    if offset > 0xffff {
        Error::new(
            span, "Compiler: Jump offset too large."
        ).panic()
    }

    .chunk.code.data[from + 0] = (offset >> 8) as u8 & 0xff
    .chunk.code.data[from + 1] = offset as u8
}

def Compiler::compile_if(&this, node: &AST, is_expression: bool = false) {
    let ifs = &node.u.if_stmt
    .compile_expression(ifs.cond)

    let false_jump = .make_jump(JumpIfFalse, ifs.cond.span)
    .chunk.push_op(Pop, ifs.cond.span)
    .compile_statement(ifs.body)
    let end_jump = .make_jump(Jump, ifs.body.span)

    .patch_jump(false_jump, ifs.cond.span)
    .chunk.push_op(Pop, ifs.cond.span)
    if ifs.els? {
        .compile_statement(ifs.els)
    }
    .patch_jump(end_jump, ifs.body.span)
}

def Compiler::compile_expression(&this, node: &AST) {
    match node.type {
        IntLiteral => {
            let value = Value::Int(node.u.num_literal.text.to_i32())
            .chunk.push_with_literal(Constant, value, node.span)
        }
        FloatLiteral => {
            let value = Value::Float(std::libc::strtod(node.u.num_literal.text, null))
            .chunk.push_with_literal(Constant, value, node.span)
        }
        StringLiteral => {
            let text = node.u.string_literal
            .chunk.push_with_literal(Constant, .make_str(text), node.span)
        }
        BoolLiteral => {
            let value = Value::Bool(node.u.bool_literal)
            .chunk.push_with_literal(Constant, value, node.span)
        }
        Identifier => .compile_variable(node.u.ident.name, node.span)
        Call => {
            let callee = node.u.call.callee

            .compile_expression(callee)

            let args = node.u.call.args
            for arg in args.iter() {
                .compile_expression(arg.expr)
            }

            .chunk.push_with_arg_u8(Call, args.size as u8, node.span)
        }
        BinaryOp => match node.u.binary.op {
            Assignment => {
                .compile_expression(node.u.binary.rhs)

                let lhs = node.u.binary.lhs
                match lhs.type {
                    Identifier => {
                        let name = lhs.u.ident.name
                        let idx = .find_local(lhs.u.ident.name, lhs.span)
                        let up_idx = .find_upvar(name, node.span)
                        
                        // Global variable
                        if idx >= 0 {
                            .chunk.push_with_arg_u16(SetLocal, idx as u16, node.span)

                        // Upvalue
                        } else if up_idx >= 0 {
                            .chunk.push_with_arg_u16(SetUpvalue, up_idx as u16, node.span)

                        // Local variable
                        } else {
                            .chunk.push_with_literal(SetGlobal, .make_str(name), node.span)

                        }
                    }
                    else => {
                        Error::new(
                            lhs.span, f"Cannot assign to {lhs.type}"
                        ).panic()
                    }
                }
            }
            And => {
                .compile_expression(node.u.binary.lhs)
                let false_jump = .make_jump(JumpIfFalse, node.span)
                .chunk.push_op(Pop, node.span)
                .compile_expression(node.u.binary.rhs)
                .patch_jump(false_jump, node.span)
            }
            Or => {
                .compile_expression(node.u.binary.lhs)
                let false_jump = .make_jump(JumpIfFalse, node.span)
                let true_jump = .make_jump(Jump, node.span)
                .patch_jump(false_jump, node.span)
                .chunk.push_op(Pop, node.span)
                .compile_expression(node.u.binary.rhs)
                .patch_jump(true_jump, node.span)
            }
            // Generic Binary operators
            else => {
                .compile_expression(node.u.binary.lhs)
                .compile_expression(node.u.binary.rhs)
                match node.u.binary.op {
                    Plus => .chunk.push_op(Add, node.span),
                    Minus => .chunk.push_op(Sub, node.span),
                    Multiply => .chunk.push_op(Mul, node.span),
                    Divide => .chunk.push_op(Div, node.span),
                    LessThan => .chunk.push_op(LessThan, node.span),
                    GreaterThan => .chunk.push_op(GreaterThan, node.span),
                    Equals => .chunk.push_op(Equal, node.span),
                    else => std::panic(`Unimplemented binary operator: {node.u.binary.op}`)
                }
            }
        }
        else => {
            Error::new(
                node.span, f"Unimplemented `{node.type}` in Compiler::compile_expression"
            ).panic()
        }
    }
}

def Compiler::compile_statement(&this, node: &AST) {
    match node.type {
        Block => {
            .begin_scope()

            for s in node.u.block.statements.iter() {
                .compile_statement(s)
            }

            .end_scope(node.span)
        }
        VarDeclaration => {
            let sym = node.u.var_decl.var.sym
            let expr = node.u.var_decl.init
            if expr? {
                .compile_expression(expr)
            } else {
                .chunk.push_op(Null, node.span)
            }
            .create_variable(sym)
            .define_variable(sym)
            .mark_variable_initialized()
        }
        Function => {
            let ast_func = node.u.func

            .create_variable(ast_func.sym)
            .mark_variable_initialized()

            let name_val = .make_str(ast_func.sym.name)
            let func_obj = allocate_object<FunctionCode>(.vm, FunctionCode)
            let chunk = Chunk::new(ast_func.span)
            func_obj.init(name_val.as_string(), chunk, ast_func.params.size as u8)

            let cc = Compiler::make(func_obj, .vm, node.span, enclosing: this)
            cc.begin_scope()
            for param in ast_func.params.iter() {
                cc.create_variable(param.sym)
                cc.mark_variable_initialized()
            }

            cc.compile_statement(ast_func.body)

            // Add a placeholder return statement if none was provided
            cc.chunk.push_with_literal(Constant, Value::Null(), node.span)
            cc.chunk.push_op(Return, node.span)
            cc.end_scope(ast_func.sym.span)

            let func_val = Value::Object(&func_obj.obj)
            .chunk.push_with_literal(Constant, func_val, node.span)

            .chunk.push_with_arg_u16(CloseFunction, cc.upvars.size as u16, node.span)
            for up in cc.upvars.iter() {
                .chunk.push_u8(up.is_local as u8, node.span)
                .chunk.push_u16(up.idx, node.span)
            }

            .define_variable(ast_func.sym)
            cc.free()
        }
        If => .compile_if(node, is_expression: false)
        While => {
            let loop = &node.u.loop
            let start = .chunk.code.size
            .compile_expression(loop.cond)
            let false_jump = .make_jump(JumpIfFalse, loop.cond.span)
            .chunk.push_op(Pop, loop.cond.span)

            .compile_statement(loop.body)

            .make_loop(start, loop.cond.span)
            .patch_jump(false_jump, loop.cond.span)
            .chunk.push_op(Pop, loop.cond.span)
        }
        For => {
            let loop = &node.u.loop
            .begin_scope()

            if loop.init? {
                .compile_statement(loop.init)
            }

            let start = .chunk.code.size
            if loop.cond? {
                .compile_expression(loop.cond)
            } else {
                .chunk.push_with_literal(Constant, Value::True(), node.span)
            }

            let false_jump = .make_jump(JumpIfFalse, node.span)
            .chunk.push_op(Pop, node.span)

            .compile_statement(loop.body)

            if loop.step? {
                .compile_statement(loop.step)
            }

            .make_loop(start, node.span)
            .patch_jump(false_jump, node.span)
            .chunk.push_op(Pop, node.span)

            .end_scope(node.span)
        }
        Return | ArrowReturn => {
            if node.u.child? {
                .compile_expression(node.u.child)
            } else {
                .chunk.push_op(Null, node.span)
            }
            .chunk.push_op(Return, node.span)
        }
        else => {
            .compile_expression(node)
            .chunk.push_op(Pop, node.span)
        }
    }
}

def Compiler::compile_ns(&this, root: &AST) {
    assert root.type == Namespace, "Root node must be a namespace."
    for stmt in root.u.ns.statements.iter() {
        .compile_statement(stmt)
    }
}

// TODO: More complex structures than just expressions?
def compile_program(vm: &VM, root: &AST): &FunctionCode {
    let func = allocate_object<FunctionCode>(vm, FunctionCode)
    let func_name = vm.copy_string("", 0)  // Empty string for script
    let chunk = Chunk::new(root.span)
    func.init(func_name.as_string(), chunk, 0)

    let compiler = Compiler::make(func, vm, root.span)
    compiler.compile_ns(root)
    compiler.chunk.push_op(Halt, root.span)
    compiler.free()

    return func
}
