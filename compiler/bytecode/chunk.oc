import std::vector::{ Vector }
import std::compact_map::{ Map }
import std::span::{ Span }
import std::mem

import @vm::value::{ Value, String, Object }
import @bytecode::instruction::{ Instruction, OpCode }

struct Chunk {
    instructions: &Vector<Instruction>
    literals: &Vector<Value>
    literal_map: &Map<Value, u32>

    // Debug info for error messages
    filename: str
    // Line number for each instruction
    // TODO: Run-length encoding or something
    lines_numbers: &Vector<u32>
}

def Chunk::new(span: Span): &Chunk {
    let chunk = mem::alloc<Chunk>()
    chunk.instructions = Vector<Instruction>::new()
    chunk.literals = Vector<Value>::new()
    chunk.literal_map = Map<Value, u32>::new()

    chunk.filename = span.start.filename
    chunk.lines_numbers = Vector<u32>::new()
    return chunk
}

def Chunk::push(&this, inst: Instruction, span: Span) {
    .instructions.push(inst)
    .lines_numbers.push(span.start.line)
}

def Chunk::push_literal(&this, op: OpCode, value: Value, span: Span) {
    let it = .literal_map.get_item(value)
    if it? {
        .push(Instruction::make_literal(op, it.value as u16), span)
        return
    }
    let idx = .literals.size
    assert idx < 65536, "Too many literals in a chunk"
    .literals.push(value)
    .literal_map[value] = idx
    .push(Instruction::make_literal(op, idx as u16), span)
}

def Chunk::literal(&this, idx: u16): Value {
    return .literals[idx as u32]
}

def Chunk::dump(&this) {
    println(f"=== Chunk from {.filename} ({.instructions.size} insts) ===")
    for let i = 0; i < .instructions.size; i += 1 {
        let inst = .instructions[i]
        let line = .lines_numbers[i]
        print(f"{line:4d}: ")
        match inst.op {
            Constant => { print("Constant: "); .literals[inst.u.lit_idx as u32].print(); }
            Add => print("Add")
            Sub => print("Sub")
            Mul => print("Mul")
            Div => print("Div")
            Return => print("Return")
            GetGlobal | SetGlobal => {
                let val = .literal(inst.u.lit_idx).as_obj() as &String
                print(f"{inst.op}: {val.data}")
            }
            GetLocal | SetLocal => print(f"{inst.op}: {inst.u.lit_idx}")
            Null => print("Null")
            Pop => print("Pop")
            True => print("True")
            False => print("False")
            Print => print(f"Print {inst.u.lit_idx}")
        }
        print("\n")
    }
}

def Chunk::free(&this) {
    .instructions.free()
    .literals.free()
    .lines_numbers.free()
    .literal_map.free()
    mem::free(this)
}