import std::vector::{ Vector }
import std::compact_map::{ Map }
import std::span::{ Span }
import std::mem

import @vm::value::{ Value, String, Object }
import @bytecode::instruction::{ Instruction, OpCode }

struct Chunk {
    instructions: &Vector<Instruction>
    literals: &Vector<Value>
    literal_map: &Map<Value, u32>

    // Debug info for error messages
    filename: str
    // Line number for each instruction
    // TODO: Run-length encoding or something
    lines_numbers: &Vector<u32>
}

def Chunk::new(span: Span): &Chunk {
    let chunk = mem::alloc<Chunk>()
    chunk.instructions = Vector<Instruction>::new()
    chunk.literals = Vector<Value>::new()
    chunk.literal_map = Map<Value, u32>::new()

    chunk.filename = span.start.filename
    chunk.lines_numbers = Vector<u32>::new()
    return chunk
}

def Chunk::push(&this, inst: Instruction, span: Span) {
    .instructions.push(inst)
    .lines_numbers.push(span.start.line)
}

def Chunk::push_literal(&this, op: OpCode, value: Value, span: Span) {
    let it = .literal_map.get_item(value)
    if it? {
        .push(Instruction::make_literal(op, it.value as u16), span)
        return
    }
    let idx = .literals.size
    assert idx < 65536, "Too many literals in a chunk"
    .literals.push(value)
    .literal_map[value] = idx
    .push(Instruction::make_literal(op, idx as u16), span)
}

def Chunk::literal(&this, idx: u16): Value {
    return .literals[idx as u32]
}

def Chunk::dump(&this) {
    let chunks_to_dump = Vector<&Chunk>::new(capacity: 1)
    defer chunks_to_dump.free()

    println(f"=== Chunk from {.filename} ({.instructions.size} insts) ===")
    for let i = 0; i < .instructions.size; i += 1 {
        let inst = .instructions[i]
        let line = .lines_numbers[i]
        print(f"{line:4d}: ")
        inst.print(this)
        if inst.op == Constant {
            let constant = .literals[inst.u.lit_idx as u32]
            if constant.is_function() {
                let f = constant.as_function()
                chunks_to_dump.push(f.chunk)
            }
        }
        print("\n")
    }

    for chunk in chunks_to_dump.iter() {
        chunk.dump()
    }
}

def Chunk::free(&this) {
    .instructions.free()
    .literals.free()
    .lines_numbers.free()
    .literal_map.free()
    mem::free(this)
}