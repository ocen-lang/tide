import std::compact_map::{ Map }
import std::traits::hash::{ hash_bytes }

import .value::{ String, Value }

//! Since the {{String}} value type is meant to be compared by
//! pointer equality, we need to wrap it in a special struct that
//! does actual character comparison when actually interning the
//! string
struct ValueCompareString {
    data: str
    len: u32
    shash: u32
}

def ValueCompareString::hash(this): u32 => .shash
def ValueCompareString::eq(this, other: ValueCompareString): bool {
    if .shash != other.shash return false
    if .len != other.len return false
    return std::libc::memcmp(.data, other.data, .len) == 0
}

struct StringPool {
    strings: &Map<ValueCompareString, &String>
}

def StringPool::make(): StringPool {
    return StringPool(
        Map<ValueCompareString, &String>::new()
    )
}

def StringPool::free(&this) {
    .strings.free()
}

def StringPool::take_string(&this, data: str, len: u32): &String {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? {
        data.free()
        return item.value
    }
    let s = String::new(data, len, candidate.shash)
    .strings.insert(candidate, s)
    return s
}

def StringPool::copy_string(&this, data: str, len: u32): &String {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? return item.value

    let s = String::new(data.copy(), len, candidate.shash)
    .strings.insert(candidate, s)
    return s
}