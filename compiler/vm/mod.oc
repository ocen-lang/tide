import std::vector::Vector
import std::compact_map::{ Map }

import @bytecode::chunk::{ Chunk }
import @bytecode::instruction::{ Instruction, OpCode }
import .value::{ Value, String, Object }
import .string_pool::{ StringPool }

struct VM {
    stack: &Vector<Value>
    globals: &Map<&String, Value>
    string_pool: StringPool
}

def VM::make(): VM {
    return VM(
        stack: Vector<Value>::new(),
        globals: Map<&String, Value>::new(),
        string_pool: StringPool::make()
    )
}

def VM::free(&this) {
    .stack.free()
    .globals.free()
    .string_pool.free()
    // FIXME: free all objects
}

def VM::make_string(&this, data: str, len: u32): Value {
    return Value::String(.string_pool.take_string(data, len))
}

def VM::add(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() + b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() + b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 + b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() + b.as_int())
    a.is_string() and b.is_string() => {
        let a_str = a.as_string()
        let b_str = b.as_string()
        return .make_string(`{a_str.data}{b_str.data}`, a_str.len + b_str.len)
    }
    else => {
        // TODO: Runtime error?
        assert false, f"Cant add {a.type_str()} and {b.type_str()}"
    }
}

def VM::sub(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() - b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() - b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 - b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() - b.as_int())
    else => {
        // TODO: Runtime error?
        assert false, f"Cant sub {a.type_str()} and {b.type_str()}"
    }
}

def VM::mul(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() * b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() * b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 * b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() * b.as_int())
    else => {
        // TODO: Runtime error?
        assert false, f"Cant mul {a.type_str()} and {b.type_str()}"
    }
}

def VM::div(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() / b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() / b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 / b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() / b.as_int())
    else => {
        // TODO: Runtime error?
        assert false, f"Cant div {a.type_str()} and {b.type_str()}"
    }
}

def VM::run(&this, chunk: &Chunk): Value {
    // TODO: branching instructions?
    for inst in chunk.instructions.iter() {
        match inst.op {
            Constant => .stack.push(chunk.literals[inst.u.lit_idx as u32])
            Add => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.add(a, b))
            }
            Sub => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.sub(a, b))
            }
            Mul => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.mul(a, b))
            }
            Div => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.div(a, b))
            }
            Return => return .stack.pop()
            GetGlobal => {
                let name = chunk.literals[inst.u.lit_idx as u32].as_obj() as &String
                let it = .globals.get_item(name)
                if not it? {
                    // TODO: Runtime error?
                    assert false, f"Global {name.data} not found"
                }
                .stack.push(it.value)
            }
            SetGlobal => {
                let name = chunk.literals[inst.u.lit_idx as u32].as_obj() as &String
                let value = .stack.pop()
                .globals.insert(name, value)
            }
            Null => .stack.push(Value::Null())
            True => .stack.push(Value::True())
            False => .stack.push(Value::False())
        }
    }
    return Value::Null()
}
