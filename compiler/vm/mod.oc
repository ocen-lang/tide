import std::vector::Vector
import std::compact_map::{ Map }
import std::span::{ Location, Span }
import std::traits::hash::{ hash_bytes }
import std::mem
import std::logging::{ log }

import ..compiler::{ Compiler }
import @errors::{ Error }
import @bytecode::{ Chunk, OpCode }
import @main::debug
import .gc
import .value::{
    Value, String, Object, ObjectType,
    NativeFunctionType, NativeFunction, FunctionCode,
    UpValue, Function
}
import .native

//! Wrapper around a string that forces comparison by value, not
//! just by a pointer (like for the interned strings we use in
//! the rest of the language).
struct ValueCompareString {
    data: str
    len: u32
    shash: u32
}

def ValueCompareString::hash(this): u32 => .shash
def ValueCompareString::eq(this, other: ValueCompareString): bool {
    if .shash != other.shash return false
    if .len != other.len return false
    return std::libc::memcmp(.data, other.data, .len) == 0
}

struct CallFrame {
    func: &Function
    chunk: &Chunk
    ip: &u8
    stack_base: u32
}

struct VM {
    frames: &Vector<CallFrame>

    // For the current frame
    func: &Function
    chunk: &Chunk
    ip: &u8
    stack_base: u32

    cur_inst_ip: &u8

    stack: &Vector<Value>
    globals: &Map<&String, Value>
    strings: &Map<ValueCompareString, Value>
    open_upvalues: &UpValue  // Linked list of open upvalues

    //! Linked list of all allocated objects
    objects: &Object
    //! Used for GC tracking
    grays: &Vector<&Object>
}

def VM::make(): VM {
    return VM(
        frames: Vector<CallFrame>::new(),
        func: null,
        chunk: null,
        ip: null,
        stack_base: 0,
        cur_inst_ip: null,
        stack: Vector<Value>::new(capacity: 256),
        globals: Map<&String, Value>::new(),
        strings: Map<ValueCompareString, Value>::new(),
        open_upvalues: null,
        objects: null,
        grays: Vector<&Object>::new()
    )
}

def VM::free(&this) {
    let cur = .objects

    .func = null
    .stack.clear()
    .globals.clear()

    gc::collect_garbage(this, null)

    .stack.free()
    .globals.free()
    .strings.free()
    .grays.free()
    .frames.free()
    log(Info, "VM freed")
}

def VM::take_string(&this, data: str, len: u32): Value {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? {
        data.free()
        return item.value
    }
    let string = gc::allocate_object<String>(ObjectType::String, this)
    string.init(data, len, candidate.shash)
    let value = Value::String(string)
    .strings.insert(candidate, value)
    return value
}

//! Takes in a pointer to compiler to mark any objects that are being held
//! by the compiler. If this is being called during compile-time, then it must
//! be passed in, otherwise it can be null.
def VM::copy_string(&this, data: str, len: u32): Value {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? return item.value

    let new_data = mem::alloc<char>(len+1) // +1 for null terminator, so we can print it
    std::libc::memcpy(new_data, data, len)

    let string = gc::allocate_object<String>(ObjectType::String, this)
    string.init(new_data, len, candidate.shash)
    let value = Value::String(string)

    // Push on the stack so GC can find it if we collect
    .stack.push(value)
    .strings.insert(candidate, value)
    .stack.pop()

    return value
}

def VM::make_function(&this, code: &FunctionCode): &Function {
    let func = gc::allocate_object<Function>(ObjectType::Function, this)
    func.init(code)
    return func
}

def VM::add(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() + b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() + b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 + b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() + b.as_int())
    a.is_string() and b.is_string() => {
        let a_str = a.as_string()
        let b_str = b.as_string()
        // FIXME: Don't pop and push these back on, just peek the values earlier
        //        We need to do this so that the GC can find the strings when we
        //        allocate the new one (which can trigger a GC collection)
        .stack.push(a)
        .stack.push(b)
        let res = .take_string(`{a_str.data}{b_str.data}`, a_str.len + b_str.len)
        .stack.pop() // b
        .stack.pop() // a
        yield res
    }
    else => .error(f"Cant add {a.type_str()} and {b.type_str()}")
}

def VM::sub(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() - b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() - b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 - b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() - b.as_int())
    else => .error(f"Cant sub {a.type_str()} and {b.type_str()}")
}

def VM::mul(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() * b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() * b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 * b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() * b.as_int())
    else => .error(f"Cant mul {a.type_str()} and {b.type_str()}")
}

def VM::div(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() / b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() / b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 / b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() / b.as_int())
    else => .error(f"Cant div {a.type_str()} and {b.type_str()}")
}

def VM::less_than(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Bool(a.as_float() < b.as_float())
    a.is_float() and b.is_int() => Value::Bool(a.as_float() < b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Bool(a.as_int() as f64 < b.as_float())
    a.is_int() and b.is_int() => Value::Bool(a.as_int() < b.as_int())
    else => .error(f"Cant compare {a.type_str()} and {b.type_str()}")
}

def VM::greater_than(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Bool(a.as_float() > b.as_float())
    a.is_float() and b.is_int() => Value::Bool(a.as_float() > b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Bool(a.as_int() as f64 > b.as_float())
    a.is_int() and b.is_int() => Value::Bool(a.as_int() > b.as_int())
    else => .error(f"Cant compare {a.type_str()} and {b.type_str()}")
}

def VM::equal(&this, a: Value, b: Value): Value {
    // Fast Path... all of these are representable as integers
    if not a.is_obj() and not b.is_obj() {
        return Value::Bool(a.u.uint == b.u.uint)
    }

    return Value::Bool(false)
}

def VM::print_value(&this, val: Value) => if {
    val.is_int() => print(`{val.as_int()}`)
    val.is_float() => print(`{val.as_float():f}`)
    val.is_bool() => print(`{val.as_bool()}`)
    val.is_null() => print("null")
    val.is_obj() => match val.as_obj().type {
        String => print(`{val.as_string().data}`)
        Function => {
            let clos = val.as_function()
            let name = val.as_function_code().name.data

            if {
                clos.upvalues? => print(`<func "{name}, {clos.upvalues.size} captures">`)
                name == "" => print("<script>")
                else => print(`<function "{name}">`)
            }
        }
        FunctionCode => {
            let name = val.as_function_code().name.data
            if name == "" {
                print("<script>")
            } else {
                print(`<function "{name}">`)
            }
        }
        NativeFunction => print(`<native {val.as_native_function().name.data}>`)
        UpValue => {
            let slot = val.as_upvalue().slot
            let upval = .stack.data[slot]
            .print_value(upval)
        }
    }
    else => .error(`Unhandled value in VM::print(): {val.u.uint:08x}`)
}

def VM::read_u8(&this): u8 => *.ip++

def VM::read_u16(&this): u16 {
    let a = .read_u8()
    let b = .read_u8()
    return (a as u16) << 8 | (b as u16)
}

def VM::add_native_function(&this, name: str, func: NativeFunctionType) {
    let s = .copy_string(name, name.len())
    .stack.push(s)

    let native_fn = gc::allocate_object<NativeFunction>(NativeFunction, this)
    native_fn.init(s.as_string(), func)
    let value = Value::Object(&native_fn.obj)
    .stack.push(value)

    .globals.insert(s.as_string(), value)

    // Pop the function and the name
    .stack.pop()
    .stack.pop()
}

def VM::setup_native_functions(&this) {
    .add_native_function("clock", native::clock)
    .add_native_function("print", native::print)
}

def VM::run(&this, code: &FunctionCode): i32 {
    .stack.push(Value::Object(&code.obj))
    let func = .make_function(code)
    .stack.pop()
    .stack.push(Value::Object(&func.obj))

    .func = func
    .chunk = code.chunk
    .ip = .chunk.code.data
    .stack_base = .stack.size

    .setup_native_functions()
    return .main_loop()
}

def VM::read_literal(&this): Value => .chunk.literal(.read_u16())

def VM::is_falsey(&this, val: Value): bool => if {
    val.is_null() => true
    val.is_bool() => not val.as_bool()
    else => false  // TODO: Custom falsey values?
}

def VM::push_frame(&this, func: &Function, stack_base: u32) {
    // Push current frame, and set up the new one
    .frames.push(CallFrame(.func, .chunk, .ip, .stack_base))
    .func = func
    .chunk = func.code.chunk
    .ip = .chunk.code.data
    .stack_base = stack_base
}

def VM::pop_frame(&this) {
    // Discard all the stack variables...
    .stack.size = .stack_base - 1

    let frame = .frames.pop()
    .func = frame.func
    .chunk = frame.chunk
    .ip = frame.ip
    .stack_base = frame.stack_base
}

[exits]
def VM::error_at(&this, span: Span, msg: str) {
    Error::new(span, msg).panic()
}

[exits]
def VM::error(&this, msg: str) {
    let inst_off = (.cur_inst_ip - .chunk.code.data) as u32
    let span = .chunk.span_for_offset(inst_off)
    .error_at(span, msg)
}

def VM::debug_dump_inst(&this, print_stack: bool) {
    if print_stack {
        print("\nStack: ()")
        for let i = 1; i < .stack.size; i++ {
            let val = .stack[i]
            if i > 0 then print(" ")
            val.print()
        }
        println("")
    }

    let off = (.ip - .chunk.code.data) as u32
    let span = .chunk.span_for_offset(off)
    print(`[VM] (L#{span.start.line:2d}) {off:4d}: `)
    .chunk.disassemble_inst(off)
}

def VM::capture_upvalue(&this, slot: u32): &UpValue {
    let cur = &.open_upvalues
    while (*cur)? and (*cur).slot > slot {
        (*cur) = (*cur).next
    }

    if (*cur)? and (*cur).slot == slot {
        return *cur
    }

    let upval = gc::allocate_object<UpValue>(ObjectType::UpValue, this)
    upval.init(slot)

    (*cur) = upval
    return upval
}

def VM::close_upvalue(&this, slot: u32) {
    while .open_upvalues? and .open_upvalues.slot >= slot {
        let upval = .open_upvalues
        let val = .stack.data[upval.slot]
        upval.closed = val
        upval.slot = 0
        .open_upvalues = upval.next
    }
}

def VM::main_loop(&this): i32 {
    while true {
        // FIXME: For `tests/native_fn.td`, having this line here
        //        causes perf to go from 1.2s -> 1.6s, _even if_
        //        the debug == false. Saving it into a local variable
        //        from the global one doesn't help either.
        if debug then .debug_dump_inst(print_stack: false)

        .cur_inst_ip = .ip
        let op = .read_u8() as OpCode
        match op {
            Halt => return 0
            Constant => .stack.push(.read_literal())
            Add => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.add(a, b))
            }
            Sub => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.sub(a, b))
            }
            Mul => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.mul(a, b))
            }
            Div => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.div(a, b))
            }
            LessThan => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.less_than(a, b))
            }
            GreaterThan => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.greater_than(a, b))
            }
            Equal => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.equal(a, b))
            }
            JumpIfFalse => {
                let off = .read_u16()
                let val = .stack.back()  // Peek only
                if .is_falsey(val) {
                    .ip = .ip + off
                }
            }
            Jump => {
                let off = .read_u16()
                .ip = .ip + off
            }
            Loop => {
                let off = .read_u16()
                .ip = .ip - off
            }
            Pop => .stack.pop()
            Return => {
                let value = .stack.pop()

                if .frames.is_empty() {
                    // Global scope, return with the value
                    if not value.is_int() {
                        .error(f"Can only return integers from the global scope")
                    }
                    return value.as_int()

                } else {
                    .close_upvalue(.stack_base)
                    .pop_frame()
                    .stack.push(value)
                }
            }
            Call => {
                let arity = .read_u8()
                let val = .stack.back(arity as u32)

                if {
                    val.is_function() => {
                        let func = val.as_function()
                        let code = func.code
                        if code.arity != arity {
                            .error(f"Function {code.name.data} expected {code.arity} arguments, got {arity}")
                        }
                        .push_frame(func, .stack.size - arity as u32)
                    }
                    val.is_native_function() => {
                        let func = val.as_native_function()
                        let res = func.func(this, arity as u32, &.stack.data[.stack.size - arity as u32])
                        .stack.size -= arity as u32 + 1  // Pop the arguments and the function
                        .stack.push(res)
                    }
                    val.is_function_code() => .error("Function should have been a func")
                    else => .error(f"Can only call functions, got {val.type_str()}")
                }
            }
            GetGlobal => {
                let name = .read_literal().as_string()
                let it = .globals.get_item(name)
                if not it? {
                    .error(f"Variable {name.data} not found")
                }
                .stack.push(it.value)
            }
            SetGlobal => {
                let name = .read_literal().as_string()
                let value = .stack.back()
                .globals.insert(name, value)
            }
            GetLocal => {
                let idx = .read_u16() + .stack_base as u16
                .stack.push(.stack.data[idx])
            }
            SetLocal => {
                let idx = .read_u16() + .stack_base as u16
                .stack.data[idx] = .stack.back()
            }
            Null => .stack.push(Value::Null())
            True => .stack.push(Value::True())
            False => .stack.push(Value::False())
            CloseFunction => {
                let arg = .stack.pop()
                if not arg.is_function_code() {
                    .error(f"Expected function, got {arg.type_str()}")
                }
                let code = arg.as_function_code()
                let func = .make_function(code)

                let num_upvals = .read_u16() as u32
                if num_upvals > 0 {
                    func.upvalues = Vector<&UpValue>::new()
                }
                for let i = 0; i < num_upvals; i++ {
                    let is_local = .read_u8() == 1
                    let index = .read_u16() as u32
                    if is_local {
                        let upval = .capture_upvalue(.stack_base + index)
                        func.upvalues += upval
                        // print(`  [VM] Upval {index} is local: {upval.slot} ({upval})\n`)

                    } else {
                        let upval = .func.upvalues[index]
                        func.upvalues += upval
                        // print(`  [VM] Upval {index} is outside: {upval.slot}\n`)
                    }
                }
                .stack.push(Value::Object(&func.obj))
            }
            GetUpvalue => {
                let idx = .read_u16() as u32
                let upval = .func.upvalues[idx]
                // print(`  [VM] Getting upval {idx} ({upval})\n`)
                if upval.slot == 0 {
                    .stack.push(upval.closed)
                } else {
                    .stack.push(.stack.data[upval.slot])
                }
            }
            SetUpvalue => {
                let idx = .read_u16() as u32
                let upval = .func.upvalues[idx]
                if upval.slot == 0 {
                    upval.closed = .stack.back()
                } else {
                    .stack.data[upval.slot] = .stack.back()
                }
            }
            CloseUpvalue => {
                .close_upvalue(.stack.size - 1)
                .stack.pop()
            }
        }
    }
    return 0
}
