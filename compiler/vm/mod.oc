import std::vector::Vector
import std::compact_map::{ Map }
import std::span::{ Location, Span }
import std::traits::hash::{ hash_bytes }
import std::mem
import std::logging::{ log }

import @errors::{ Error }
import @bytecode::{ Chunk, OpCode }
import @main::debug
import .value::{ Value, String, Object, ObjectType, NativeFunctionType, NativeFunction }
import .native

//! Wrapper around a string that forces comparison by value, not
//! just by a pointer (like for the interned strings we use in
//! the rest of the language).
struct ValueCompareString {
    data: str
    len: u32
    shash: u32
}

def ValueCompareString::hash(this): u32 => .shash
def ValueCompareString::eq(this, other: ValueCompareString): bool {
    if .shash != other.shash return false
    if .len != other.len return false
    return std::libc::memcmp(.data, other.data, .len) == 0
}

struct CallFrame {
    chunk: &Chunk
    ip: &u8
    stack_base: u32
}

struct VM {
    frames: &Vector<CallFrame>
    
    // For the current frame
    chunk: &Chunk
    ip: &u8
    stack_base: u32

    stack: &Vector<Value>
    globals: &Map<&String, Value>
    strings: &Map<ValueCompareString, Value>

    //! Linked list of all allocated objects
    objects: &Object
}

def VM::make(): VM {
    return VM(
        frames: Vector<CallFrame>::new(),
        chunk: null,
        ip: null,
        stack_base: 0,
        stack: Vector<Value>::new(),
        globals: Map<&String, Value>::new(),
        strings: Map<ValueCompareString, Value>::new(),
        objects: null
    )
}

def VM::free(&this) {
    .stack.free()
    .globals.free()
    .strings.free()
    let cur = .objects
    while cur? {
        if debug {
            print("Freeing object:")
            cur.print()
            println("")
        }
        let next = cur.next
        cur.free()
        cur = next
    }
    log(Info, "VM freed")
}

//! Allocate a new Object of type `T` and return a reference to it.
//!
//! Precondition: First field of `T` must be a `Object` field.
def allocate_object<T>(vm: &VM, type: ObjectType): &T {
    let res = mem::alloc<T>()
    res.obj.type = type
    res.obj.next = vm.objects
    vm.objects = &res.obj
    return res
}

def VM::take_string(&this, data: str, len: u32): Value {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? {
        data.free()
        return item.value
    }
    let string = allocate_object<String>(this, ObjectType::String)
    string.init(data, len, candidate.shash)
    let value = Value::String(string)
    .strings.insert(candidate, value)
    return value
}

def VM::copy_string(&this, data: str, len: u32): Value {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? return item.value

    let string = allocate_object<String>(this, ObjectType::String)
    let new_data = mem::alloc<char>(len)
    std::libc::memcpy(new_data, data, len)
    string.init(new_data, len, candidate.shash)
    let value = Value::String(string)
    .strings.insert(candidate, value)
    return value
}

def VM::add(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() + b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() + b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 + b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() + b.as_int())
    a.is_string() and b.is_string() => {
        let a_str = a.as_string()
        let b_str = b.as_string()
        return .take_string(`{a_str.data}{b_str.data}`, a_str.len + b_str.len)
    }
    else => .error(f"Cant add {a.type_str()} and {b.type_str()}")
}

def VM::sub(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() - b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() - b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 - b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() - b.as_int())
    else => .error(f"Cant sub {a.type_str()} and {b.type_str()}")
}

def VM::mul(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() * b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() * b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 * b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() * b.as_int())
    else => .error(f"Cant mul {a.type_str()} and {b.type_str()}")
}

def VM::div(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() / b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() / b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 / b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() / b.as_int())
    else => .error(f"Cant div {a.type_str()} and {b.type_str()}")
}

def VM::less_than(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Bool(a.as_float() < b.as_float())
    a.is_float() and b.is_int() => Value::Bool(a.as_float() < b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Bool(a.as_int() as f64 < b.as_float())
    a.is_int() and b.is_int() => Value::Bool(a.as_int() < b.as_int())
    else => .error(f"Cant compare {a.type_str()} and {b.type_str()}")
}

def VM::greater_than(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Bool(a.as_float() > b.as_float())
    a.is_float() and b.is_int() => Value::Bool(a.as_float() > b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Bool(a.as_int() as f64 > b.as_float())
    a.is_int() and b.is_int() => Value::Bool(a.as_int() > b.as_int())
    else => .error(f"Cant compare {a.type_str()} and {b.type_str()}")
}

def VM::equal(&this, a: Value, b: Value): Value {
    // Fast Path... all of these are representable as integers
    if not a.is_obj() and not b.is_obj() {
        return Value::Bool(a.u.uint == b.u.uint)
    }

    .error(f"Cant compare {a.type_str()} and {b.type_str()}")
}

def VM::print_value(&this, val: Value) => if {
    val.is_int() => print(`{val.as_int()}`)
    val.is_float() => print(`{val.as_float():f}`)
    val.is_bool() => print(`{val.as_bool()}`)
    val.is_null() => print("null")
    val.is_obj() => match val.as_obj().type {
        String => print(`{val.as_string().data}`)
        Function => print(`<function {val.as_function().name.data}>`)
        NativeFunction => print(`<native {val.as_native_function().name.data}>`)
    }
    else => .error(`Unhandled value in VM::print(): {val.u.uint:08x}`)
}

def VM::read_u8(&this): u8 => *.ip++

def VM::read_u16(&this): u16 {
    let a = .read_u8()
    let b = .read_u8()
    return (a as u16) << 8 | (b as u16)
}

def VM::add_native_function(&this, name: str, func: NativeFunctionType) {
    let s = .copy_string(name, name.len())
    .stack.push(s)

    let native_fn = allocate_object<NativeFunction>(this, NativeFunction)
    native_fn.init(s.as_string(), func)
    let value = Value::Object(&native_fn.obj)
    .stack.push(value)

    .globals.insert(s.as_string(), value)

    // Pop the function and the name
    .stack.pop()
    .stack.pop()
}

def VM::setup_native_functions(&this) {
    .add_native_function("clock", native::clock)
    .add_native_function("print", native::print)
}

def VM::run(&this, chunk: &Chunk): i32 {
    .setup_native_functions()
    .stack.push(Value::Null())
    .chunk = chunk
    .ip = chunk.code.data
    .stack_base = 1
    return .main_loop()
}

def VM::read_literal(&this): Value => .chunk.literal(.read_u16())

def VM::is_falsey(&this, val: Value): bool => if {
    val.is_null() => true
    val.is_bool() => not val.as_bool()
    else => false  // TODO: Custom falsey values?
}

def VM::push_frame(&this, chunk: &Chunk, ip: &u8, stack_base: u32) {
    // Push current frame, and set up the new one
    .frames.push(CallFrame(.chunk, .ip, .stack_base))
    .chunk = chunk
    .ip = ip
    .stack_base = stack_base
}

def VM::pop_frame(&this) {
    // Discard all the stack variables...
    .stack.size = .stack_base - 1

    let frame = .frames.pop()
    .chunk = frame.chunk
    .ip = frame.ip
    .stack_base = frame.stack_base
}

[exits]
def VM::error(&this, msg: str) {
    let off = (.ip - .chunk.code.data) as u32 - 1  // -1 because we read the opcode
    let line = .chunk.lines_numbers[off]
    let err_loc = .chunk.start_span.start
    err_loc.line = line as u32
    err_loc.col = 1
    let span = Span(err_loc, err_loc)
    Error::new(span, msg).panic()
}

def VM::main_loop(&this): i32 {
    // TODO: branching instructions?
    while true {
        if debug {
            print("\nStack: ")
            for let i = 0; i < .stack.size; i++ {
                let val = .stack[i]
                if i > 0 then print(", ")
                .print_value(val)
            }
            println("")

            let off = (.ip - .chunk.code.data) as u32
            let line = .chunk.lines_numbers[off]
            print(`[VM] (L#{line:2d}) {off:4d}: `)
            .chunk.disassemble_inst(off)

        }
        let op = .read_u8() as OpCode
        match op {
            Halt => return 0
            Constant => .stack.push(.read_literal())
            Add => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.add(a, b))
            }
            Sub => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.sub(a, b))
            }
            Mul => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.mul(a, b))
            }
            Div => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.div(a, b))
            }
            LessThan => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.less_than(a, b))
            }
            GreaterThan => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.greater_than(a, b))
            }
            Equal => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.equal(a, b))
            }
            JumpIfFalse => {
                let off = .read_u16()
                let val = .stack.back()  // Peek only
                if .is_falsey(val) {
                    .ip = .ip + off
                }
            }
            Jump => {
                let off = .read_u16()
                .ip = .ip + off
            }
            Loop => {
                let off = .read_u16()
                .ip = .ip - off
            }
            Pop => .stack.pop()
            Return => {
                let value = .stack.pop()

                if .frames.is_empty() {
                    // Global scope, return with the value
                    if not value.is_int() {
                        .error(f"Can only return integers from the global scope")
                    }
                    return value.as_int()

                } else {
                    .pop_frame()
                    .stack.push(value)
                }
            }
            Call => {
                let arity = .read_u8()
                let val = .stack.back(arity as u32)

                // TODO: Location?
                if {
                    val.is_function() => {
                        let func = val.as_function()
                        if func.arity != arity {
                            .error(f"Function {func.name.data} expected {func.arity} arguments, got {arity}")
                        }
                        .push_frame(func.chunk, func.chunk.code.data, .stack.size - arity as u32)
                    }
                    val.is_native_function() => {
                        let func = val.as_native_function()
                        let res = func.func(this, arity as u32, &.stack.data[.stack.size - arity as u32])
                        .stack.size -= arity as u32 + 1  // Pop the arguments and the function
                        .stack.push(res)
                    }
                    else => .error(f"Can only call functions, got {val.type_str()}")
                }
            }
            GetGlobal => {
                let name = .read_literal().as_string()
                let it = .globals.get_item(name)
                if not it? {
                    .error(f"Variable {name.data} not found")
                }
                .stack.push(it.value)
            }
            SetGlobal => {
                let name = .read_literal().as_string()
                let value = .stack.back()
                .globals.insert(name, value)
            }
            GetLocal => {
                let idx = .read_u16() + .stack_base as u16
                .stack.push(.stack.data[idx])
            }
            SetLocal => {
                let idx = .read_u16() + .stack_base as u16
                .stack.data[idx] = .stack.back()
            }
            Null => .stack.push(Value::Null())
            True => .stack.push(Value::True())
            False => .stack.push(Value::False())
        }
    }
    return 0
}
