import std::vector::Vector
import std::compact_map::{ Map }
import std::traits::hash::{ hash_bytes }
import std::mem

import @bytecode::chunk::{ Chunk }
import @bytecode::instruction::{ Instruction, OpCode }
import .value::{ Value, String, Object, ObjectType }

//! Wrapper around a string that forces comparison by value, not
//! just by a pointer (like for the interned strings we use in
//! the rest of the language).
struct ValueCompareString {
    data: str
    len: u32
    shash: u32
}

def ValueCompareString::hash(this): u32 => .shash
def ValueCompareString::eq(this, other: ValueCompareString): bool {
    if .shash != other.shash return false
    if .len != other.len return false
    return std::libc::memcmp(.data, other.data, .len) == 0
}

struct VM {
    stack: &Vector<Value>
    globals: &Map<&String, Value>
    strings: &Map<ValueCompareString, Value>

    //! Linked list of all allocated objects
    objects: &Object
}

def VM::make(): VM {
    return VM(
        stack: Vector<Value>::new(),
        globals: Map<&String, Value>::new(),
        strings: Map<ValueCompareString, Value>::new(),
        objects: null
    )
}

def VM::free(&this) {
    .stack.free()
    .globals.free()
    .strings.free()
    let cur = .objects
    while cur? {
        print("Freeing object:")
        cur.print()
        println("")
        let next = cur.next
        cur.free()
        cur = next
    }
    println("[+] VM freed")
}

//! Allocate a new Object of type `T` and return a reference to it.
//!
//! Precondition: First field of `T` must be a `Object` field.
def allocate_object<T>(vm: &VM, type: ObjectType): &T {
    let res = mem::alloc<T>()
    res.obj.type = type
    res.obj.next = vm.objects
    vm.objects = &res.obj
    return res
}

def VM::take_string(&this, data: str, len: u32): Value {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? {
        data.free()
        return item.value
    }
    let string = allocate_object<String>(this, ObjectType::String)
    string.init(data, len, candidate.shash)
    let value = Value::String(string)
    .strings.insert(candidate, value)
    return value
}

def VM::copy_string(&this, data: str, len: u32): Value {
    let candidate = ValueCompareString(data, len, hash_bytes(data as &u8, len))
    let item = .strings.get_item(candidate)
    if item? return item.value

    let string = allocate_object<String>(this, ObjectType::String)
    let new_data = mem::alloc<char>(len)
    std::libc::memcpy(new_data, data, len)
    string.init(new_data, len, candidate.shash)
    let value = Value::String(string)
    .strings.insert(candidate, value)
    return value
}

def VM::add(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() + b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() + b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 + b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() + b.as_int())
    a.is_string() and b.is_string() => {
        let a_str = a.as_string()
        let b_str = b.as_string()
        return .take_string(`{a_str.data}{b_str.data}`, a_str.len + b_str.len)
    }
    else => {
        // TODO: Runtime error?
        assert false, f"Cant add {a.type_str()} and {b.type_str()}"
    }
}

def VM::sub(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() - b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() - b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 - b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() - b.as_int())
    else => {
        // TODO: Runtime error?
        assert false, f"Cant sub {a.type_str()} and {b.type_str()}"
    }
}

def VM::mul(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() * b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() * b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 * b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() * b.as_int())
    else => {
        // TODO: Runtime error?
        assert false, f"Cant mul {a.type_str()} and {b.type_str()}"
    }
}

def VM::div(&this, a: Value, b: Value): Value => if {
    a.is_float() and b.is_float() => Value::Float(a.as_float() / b.as_float())
    a.is_float() and b.is_int() => Value::Float(a.as_float() / b.as_int() as f64)
    a.is_int() and b.is_float() => Value::Float(a.as_int() as f64 / b.as_float())
    a.is_int() and b.is_int() => Value::Int(a.as_int() / b.as_int())
    else => {
        // TODO: Runtime error?
        assert false, f"Cant div {a.type_str()} and {b.type_str()}"
    }
}

//! `print()` intrinsic function
def VM::print(&this, inst: &Instruction) {
    let num_args = inst.u.lit_idx as u32
    for let i = 0; i < num_args; i++ {
        // NOTE: We want to print them in the correct order
        let idx = .stack.size - num_args + i
        let arg = .stack[idx]
        if i > 0 then print(" ")
        if {
            arg.is_int() => print(`{arg.as_int()}`)
            arg.is_float() => print(`{arg.as_float():f}`)
            arg.is_bool() => print(`{arg.as_bool()}`)
            arg.is_string() => print(`{arg.as_string().data}`)
            arg.is_null() => print("null")
            else => std::panic(`Unhandled value in VM::print(): {arg.u.uint:08x}`)
        }
    }
    .stack.size -= num_args
    println("")

    // Push null since this behaves like a function call
    .stack.push(Value::Null())
}

def VM::run(&this, chunk: &Chunk): Value {
    // TODO: branching instructions?
    for inst in chunk.instructions.iter() {
        match inst.op {
            Constant => .stack.push(chunk.literals[inst.u.lit_idx as u32])
            Add => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.add(a, b))
            }
            Sub => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.sub(a, b))
            }
            Mul => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.mul(a, b))
            }
            Div => {
                let b = .stack.pop()
                let a = .stack.pop()
                .stack.push(.div(a, b))
            }
            Pop => .stack.pop()
            Print => .print(&inst)
            Return => return .stack.pop()
            GetGlobal => {
                let name = chunk.literals[inst.u.lit_idx as u32].as_obj() as &String
                let it = .globals.get_item(name)
                if not it? {
                    // TODO: Runtime error?
                    assert false, f"Global {name.data} not found"
                }
                .stack.push(it.value)
            }
            SetGlobal => {
                let name = chunk.literals[inst.u.lit_idx as u32].as_obj() as &String
                let value = .stack.pop()
                .globals.insert(name, value)
            }
            GetLocal => {
                let idx = inst.u.lit_idx
                .stack.push(.stack.data[idx])
            }
            SetLocal => {
                let idx = inst.u.lit_idx
                .stack.data[idx] = .stack.back()
            }
            Null => .stack.push(Value::Null())
            True => .stack.push(Value::True())
            False => .stack.push(Value::False())
        }
    }
    return Value::Null()
}
