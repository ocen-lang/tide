//! Value for the bytecode VM
//!
//! (Not to be confused with the {{std::value}} module, which is for representing parsed JSON values.)

import std::mem


const NANISH: u64       = 0x7ffc000000000000u64
const NAN_MASK: u64     = 0xffff000000000000u64
const BOOL_MASK: u64    = 0x7ffe000000000002u64
const INT_MASK: u64     = 0x7ffc000000000000u64
const NULL_VALUE: u64   = 0x7ffe000000000000u64
const OBJECT_MASK: u64  = 0xfffc000000000000u64

union ValueData {
    flot: f64
    uint: u64
}

//! NaN-boxed value
struct Value {
    u: ValueData
}

def Value::hash(this): u32 => .u.uint.hash()
def Value::eq(this, other: Value): bool => .u.uint == other.u.uint

def Value::from_float(f: f64): Value {
    let v: Value
    v.u.flot = f
    return v
}

def Value::from_uint(i: u64): Value {
    let v: Value
    v.u.uint = i
    return v
}

def Value::is_float(this): bool => .u.uint & NANISH != NANISH
def Value::as_float(this): f64 => .u.flot

def Value::is_null(this): bool => .u.uint == NULL_VALUE

def Value::is_bool(this): bool => .u.uint & BOOL_MASK == BOOL_MASK
def Value::is_true(this): bool => .u.uint == BOOL_MASK | 3
def Value::is_false(this): bool => .u.uint == BOOL_MASK | 2
def Value::as_bool(this): bool => (.u.uint & 1) as bool

def Value::is_int(this): bool => .u.uint & NAN_MASK == INT_MASK
def Value::as_int(this): i32 => .u.uint as i32

def Value::is_obj(this): bool => .u.uint & NAN_MASK == OBJECT_MASK
def Value::as_obj(this): &Object => (.u.uint & 0xFFFFFFFFFFFF) as &Object
def Value::is_obj_type(this, type: ObjectType): bool {
    if not .is_obj() return false
    return .as_obj().type == type
}

def Value::is_string(this): bool => .is_obj_type(String)
def Value::as_string(this): &String => .as_obj() as &String

def Value::is_function(this): bool => .is_obj_type(Function)
def Value::as_function(this): &Function => .as_obj() as &Function

def Value::Float(f: f64): Value => Value::from_float(f)
def Value::True(): Value => Value::from_uint(BOOL_MASK | 3)
def Value::False(): Value => Value::from_uint(BOOL_MASK | 2)
def Value::Bool(b: bool): Value => if b then Value::True() else Value::False()
def Value::Null(): Value => Value::from_uint(NULL_VALUE)
def Value::Int(i: i32): Value => Value::from_uint(i as u32 as u64 | INT_MASK)
def Value::Object(obj: &Object): Value => Value::from_uint(obj as u64 | OBJECT_MASK)
def Value::String(s: &String): Value => Value::Object(s as &Object)


def Value::type_str(this): str => if {
    .is_float() => "float"
    .is_null() => "null"
    .is_true() => "true"
    .is_false() => "false"
    .is_int() => "int"
    .is_obj() => {
        let obj = .as_obj()
        yield match obj.type {
            String => "string"
            Function => "function"
        }
    }
    else => "<unknown>"
}

def Value::print(this) => if {
    .is_float() => print(`{.as_float()}`)
    .is_null() => print("null")
    .is_true() => print("true")
    .is_false() => print("false")
    .is_int() => print(`{.as_int()}`)
    .is_obj() => .as_obj().print()
    else => {
        assert false, f"Unknown value type in Value::print({.u.uint}, {.u.flot})"
    }
}

enum ObjectType {
    String
    Function
}

//! Generic Heap-allocated object. Should only be
//! instantiated through the VM, not allocated manually.
struct Object {
    type: ObjectType
    next: &Object
}

def Object::free(&this) {
    match .type {
        String => {
            let s = this as &String
            s.data.free()
        }
        Function => {
            let f = this as &Function
            f.chunk.free()
            // NOTE: A function does not own its name
        }
    }
    mem::free(this)
}

def Object::print(&this) {
    match .type {
        String => {
            let s = this as &String
            print(`"{s.data}"`)
        }
        Function => {
            let f = this as &Function
            print(`<function {f.name.data}>`)
        }
    }
}

//! An *interned* string
struct String {
    obj: Object
    data: str
    len: u32
    shash: u32
}

def String::hash(&this): u32 => .shash
def String::eq(&this, other: &String): bool => this == other

//! Expects `obj` to already be initialized
def String::init(&this, data: str, len: u32, shash: u32) {
    .data = data
    .len = len
    .shash = shash
}

struct Function {
    obj: Object
    name: &String
    chunk: &Chunk
}

//! Expects `obj` to already be initialized
def Function::init(&this, name: &String, chunk: &Chunk) {
    .name = name
    .chunk = chunk
}