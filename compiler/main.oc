//* Entry point for the compiler

import std::fs
import std::libc::{ exit, system }
import std::vector::{ Vector }
import std::buffer::{ Buffer }
import std::span::{ Span }
import std::sv::{ SV }
import std::mem
import std::{ shift_args }
import std::logging::{ init_logging, log }

import .ast::nodes::{ * }
import .parser::{ Parser }
import .lexer::{ Lexer }
import .compiler::{ compile_program }
import .vm::{ VM }
import .vm::gc
import .vm::value::{ Value }
import .bump_alloc

def usage(code: i32, full: bool) {
    println("Usage:")
    println("   ./tide [--help] [compile-options] <file>")
    if not full then exit(code)

    println("--------------------------------------------------------")
    println("Compile Options:")
    println("    -s             Silent mode (no debug output)")
    println("    -d             Emit debug information (default: false)")
    println("    -h             Display this information")
    exit(code)
}

let filename: str = null
let silent: bool = false
let debug: bool = false

// @compiler c_flag "-O3 -flto"

def parse_args(argc: &i32, argv: &&str) {

    while *argc > 0 {
        let arg = shift_args(argc, argv)
        match arg {
            "--help" => usage(code: 0, true)
            "-s" => silent = true
            "-d" => debug = true
            else => {
                if arg[0] == '-' {
                    println("Unknown option: %s", arg)
                    usage(1, true)
                } else if not filename? {
                    filename = arg
                } else {
                    println("Unknown option/argument: '%s'", arg)
                    usage(code: 1, true)
                }
            }
        }
    }

    if not filename? {
        println("No file specified")
        usage(code: 1, false)
    }

    if {
        silent => init_logging(Error, time_format: null)
        debug => init_logging(Debug, time_format: null)
        else => init_logging(Info, time_format: null)
    }
}

def main(argc: i32, argv: &str) {
    bump_alloc::initialize()

    let program_name = shift_args(&argc, &argv)
    parse_args(&argc, &argv)

    let parser = Parser::make()
    let ast = parser.parse_file(filename)
    parser.exit_with_errors_if_any()

    log(Info, f"Used {bump_alloc::cursor} bytes of memory for parsing")
    // mem::reset_to_default_allocator()

    gc::initialize_gc_allocator()

    gc::state::paused = true
    let vm = VM::make()
    gc::set_vm(&vm)
    gc::state::paused = false
    let script = compile_program(&vm, ast)

    if debug {
        // Throw the script on the stack to prevent it from being collected
        let val = Value::Object(&script.obj)
        vm.stack.push(val)

        script.chunk.dump()
        println("============================================")
        log(Info, "Running VM:")

        vm.stack.pop()
    }

    let status = vm.run(script)
    vm.free()
    gc::print_stats(&vm)
    std::exit(status)
}
